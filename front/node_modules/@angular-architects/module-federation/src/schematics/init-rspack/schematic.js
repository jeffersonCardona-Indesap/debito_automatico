"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = init;
const tslib_1 = require("tslib");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const core_1 = require("@angular-devkit/core");
const json5 = tslib_1.__importStar(require("json5"));
const path = tslib_1.__importStar(require("path"));
const RSPACK_DEPS = {
    '@module-federation/enhanced': '0.8.7',
};
const RSPACK_DEV_DEPS = {
    '@ng-rsbuild/plugin-angular': '19.0.0-alpha.14',
};
function init(options) {
    return function (tree, context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { workspace, projectName, projectRoot, projectSourceRoot, manifestPath, projectConfig, tsConfigName, workspaceFileName, main, } = normalizeOptions(tree, options);
            const remoteMap = yield generateRemoteMap(workspace, projectName);
            const generateRule = yield generateRsBuildConfig(remoteMap, projectRoot, projectSourceRoot, options);
            if (options.type === 'dynamic-host') {
                generteManifest(tree, manifestPath, remoteMap);
            }
            updateProjectConfig(projectConfig, parseInt(options.port));
            updateTsConfig(tree, tsConfigName);
            updateLocalTsConfig(projectRoot, tree);
            writeProjectConfig(tree, workspaceFileName, workspace);
            updatePackageJson(tree, projectName, projectRoot, RSPACK_DEPS, RSPACK_DEV_DEPS);
            context.addTask(new tasks_1.RunSchematicTask('patch', {}), [
                context.addTask(new tasks_1.NodePackageInstallTask()),
            ]);
            return (0, schematics_1.chain)([
                ...(generateRule ? [generateRule] : []),
                makeMainAsync(main, options),
            ]);
        });
    };
}
function normalizeOptions(tree, options) {
    var _a, _b, _c, _d;
    const workspaceFileName = getWorkspaceFileName(tree);
    const workspace = JSON.parse(tree.read(workspaceFileName).toString('utf8'));
    if (!options.project) {
        options.project = workspace.defaultProject;
    }
    const projectNames = Object.keys(workspace.projects);
    if (!options.project && projectNames.length > 0) {
        options.project = projectNames[0];
    }
    if (!options.project) {
        throw new Error(`No default project found. Please specifiy a project name!`);
    }
    const projectName = options.project;
    const projectConfig = workspace.projects[projectName];
    if (!projectConfig) {
        throw new Error(`Project ${projectName} not found!`);
    }
    const projectRoot = (_a = projectConfig.root) === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/');
    const projectSourceRoot = (_b = projectConfig.sourceRoot) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/');
    const manifestPath = path
        .join(projectRoot, 'public/mf.manifest.json')
        .replace(/\\/g, '/');
    const tsConfigName = tree.exists('tsconfig.base.json')
        ? 'tsconfig.base.json'
        : 'tsconfig.json';
    const main = (_c = projectConfig.architect.build.options.main) !== null && _c !== void 0 ? _c : projectConfig.architect.build.options.browser;
    const port = (_d = parseInt(options.port)) !== null && _d !== void 0 ? _d : 4200;
    options.port = String(port);
    return {
        workspace,
        projectName,
        projectRoot,
        projectSourceRoot,
        manifestPath,
        projectConfig,
        tsConfigName,
        workspaceFileName,
        main,
    };
}
function makeMainAsync(main, options) {
    return function (tree) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mainPath = path.dirname(main);
            const bootstrapName = path.join(mainPath, 'bootstrap.ts');
            if (tree.exists(bootstrapName)) {
                console.info(`${bootstrapName} already exists.`);
                return;
            }
            const mainContent = tree.read(main);
            tree.create(bootstrapName, mainContent);
            let newMainContent = '';
            if (options.type === 'dynamic-host') {
                newMainContent = `import { initFederation } from '@angular-architects/module-federation/runtime';

initFederation('mf.manifest.json');

//
// [HINT] Use this function to load remotes (e.g. in the routing config):
// import { loadRemoteModule } from '@angular-architects/module-federation/runtime';
//

import('./bootstrap');

`;
            }
            else {
                newMainContent =
                    "import('./bootstrap')\n\t.catch(err => console.error(err));\n";
            }
            tree.overwrite(main, newMainContent);
        });
    };
}
function getWorkspaceFileName(tree) {
    if (tree.exists('angular.json')) {
        return 'angular.json';
    }
    if (tree.exists('workspace.json')) {
        return 'workspace.json';
    }
    throw new Error("angular.json or workspace.json expected! Did you call this in your project's root?");
}
function updatePackageJson(tree, projectName, projectRoot, deps, devDeps) {
    const packageJson = JSON.parse(tree.read('package.json').toString('utf-8'));
    if (!packageJson.scripts) {
        packageJson.scripts = {};
    }
    if (!packageJson.dependencies) {
        packageJson.dependencies = {};
    }
    if (!packageJson.devDependencies) {
        packageJson.devDependencies = {};
    }
    packageJson.dependencies = Object.assign(Object.assign({}, packageJson.dependencies), deps);
    packageJson.devDependencies = Object.assign(Object.assign({}, packageJson.devDependencies), devDeps);
    if (!packageJson.scripts['run:all']) {
        packageJson.scripts['run:all'] =
            'node node_modules/@angular-architects/module-federation/src/server/mf-dev-server.js';
    }
    const prefix = projectRoot ? `cd ${projectRoot} && ` : '';
    const startScriptName = `start:${projectName}`;
    const buildScriptName = `build:${projectName}`;
    packageJson.scripts[startScriptName] = `${prefix}rsbuild dev`;
    packageJson.scripts[buildScriptName] = `${prefix}rsbuild build`;
    if (!projectRoot && packageJson.scripts['start']) {
        packageJson.scripts['original-start'] = packageJson.scripts['start'];
    }
    if (!projectRoot && packageJson.scripts['build']) {
        packageJson.scripts['original-build'] = packageJson.scripts['build'];
    }
    if (!projectRoot) {
        packageJson.scripts['start'] = `rsbuild dev`;
        packageJson.scripts['build'] = `rsbuild build`;
    }
    printScriptInfo(projectRoot, startScriptName, buildScriptName);
    tree.overwrite('package.json', JSON.stringify(packageJson, null, 2));
}
function printScriptInfo(projectRoot, startScriptName, buildScriptName) {
    console.info();
    console.info(`[INFO] Please remember that the rspack integration is in early stages`);
    console.info(`[INFO] Use the following script to start and build your project:`);
    if (projectRoot) {
        console.info(`[INFO] npm run ${startScriptName}, npm run ${buildScriptName}`);
    }
    else {
        console.info(`[INFO] npm start, npm run build`);
    }
    console.info();
}
function generateRsBuildConfig(remoteMap, projectRoot, projectSourceRoot, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tmpl = (0, schematics_1.url)('./files');
        const applied = (0, schematics_1.apply)(tmpl, [
            (0, schematics_1.template)(Object.assign(Object.assign({ projectRoot,
                projectSourceRoot,
                remoteMap }, options), { tmpl: '' })),
            (0, schematics_1.move)(projectRoot),
        ]);
        return (0, schematics_1.mergeWith)(applied);
    });
}
function writeProjectConfig(tree, workspaceFileName, workspace) {
    tree.overwrite(workspaceFileName, JSON.stringify(workspace, null, '\t'));
}
function updateLocalTsConfig(projectRoot, tree) {
    const localTsConfig = path.join(projectRoot, 'tsconfig.app.json');
    if (tree.exists(localTsConfig)) {
        updateTsConfig(tree, localTsConfig);
    }
}
function updateProjectConfig(projectConfig, port) {
    var _a, _b;
    if ((_a = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.architect) === null || _a === void 0 ? void 0 : _a.build) {
        projectConfig.architect['original-build'] = projectConfig.architect.build;
        delete projectConfig.architect.build;
    }
    if ((_b = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.architect) === null || _b === void 0 ? void 0 : _b.serve) {
        projectConfig.architect['original-serve'] = projectConfig.architect.serve;
        delete projectConfig.architect.serve;
        const target = projectConfig.architect['original-serve'];
        target.options = Object.assign(Object.assign({}, target.options), { port: port || 4200 });
    }
}
function generteManifest(tree, manifestPath, remoteMap) {
    tree.create(manifestPath, JSON.stringify(remoteMap, null, '\t'));
}
function updateTsConfig(tree, tsConfigName) {
    const tsConfig = json5.parse(tree.read(tsConfigName).toString('utf-8'));
    const target = tsConfig.compilerOptions.target;
    let targetVersion = 2022;
    if (target &&
        target.toLocaleLowerCase().startsWith('es') &&
        target.length > 2) {
        targetVersion = parseInt(target.substring(2));
    }
    if (targetVersion < 2020) {
        tsConfig.compilerOptions.target = 'es2020';
    }
    tree.overwrite(tsConfigName, JSON.stringify(tsConfig, null, 2));
}
function generateRemoteMap(workspace, projectName) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const result = {};
    for (const p in workspace.projects) {
        const project = workspace.projects[p];
        const projectType = (_a = project.projectType) !== null && _a !== void 0 ? _a : 'application';
        if (p !== projectName &&
            projectType === 'application' &&
            (((_b = project === null || project === void 0 ? void 0 : project.architect) === null || _b === void 0 ? void 0 : _b.serve) || ((_c = project === null || project === void 0 ? void 0 : project.architect) === null || _c === void 0 ? void 0 : _c['original-serve'])) &&
            (((_d = project === null || project === void 0 ? void 0 : project.architect) === null || _d === void 0 ? void 0 : _d.build) || ((_e = project === null || project === void 0 ? void 0 : project.architect) === null || _e === void 0 ? void 0 : _e['original-build']))) {
            const pPort = (_l = (_h = (_g = (_f = project.architect.serve) === null || _f === void 0 ? void 0 : _f.options) === null || _g === void 0 ? void 0 : _g.port) !== null && _h !== void 0 ? _h : (_k = (_j = project.architect['original-serve']) === null || _j === void 0 ? void 0 : _j.options) === null || _k === void 0 ? void 0 : _k.port) !== null && _l !== void 0 ? _l : 4200;
            result[core_1.strings.camelize(p)] = `http://localhost:${pPort}/remoteEntry.js`;
        }
    }
    if (Object.keys(result).length === 0) {
        result['mfe1'] = `http://localhost:3000/remoteEntry.js`;
    }
    return result;
}
//# sourceMappingURL=schematic.js.map