"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withFederation = withFederation;
exports.applyFederation = applyFederation;
const tslib_1 = require("tslib");
const plugin_script_module_1 = require("./plugin-script-module");
const skip_list_1 = require("../utils/skip-list");
const webpack_1 = require("../webpack");
function withFederation(config) {
    //
    // This provides partial application for better DX,
    // as it allows to split the config into a file with
    // rsbuild and an other one with federation settings
    //
    return (rsbuildConfig) => {
        return applyFederation(rsbuildConfig, config);
    };
}
function applyFederation(rsbuildConfig, federationConfig) {
    var _a, _b, _c;
    const { skip } = federationConfig, mfConfig = tslib_1.__rest(federationConfig, ["skip"]);
    const normalizedSkip = (0, skip_list_1.normalizeSkipList)(skip);
    const mappings = new webpack_1.SharedMappings();
    mappings.register((0, webpack_1.findRootTsConfigJson)());
    const shared = ((_a = mfConfig.options.shared) !== null && _a !== void 0 ? _a : {});
    const sharedWithLibs = Object.assign(Object.assign({}, mappings.getDescriptors()), shared);
    const filteredSkipList = (0, skip_list_1.applySkipList)(normalizedSkip, sharedWithLibs);
    mfConfig.options.shared = filteredSkipList;
    const config = Object.assign(Object.assign({}, rsbuildConfig), { resolve: Object.assign(Object.assign({}, rsbuildConfig.resolve), { alias: Object.assign(Object.assign({}, (_b = rsbuildConfig.resolve) === null || _b === void 0 ? void 0 : _b.alias), mappings.getAliases()) }), dev: Object.assign(Object.assign({}, rsbuildConfig.dev), { 
            // chunkFormat: 'module' does not work with hmr yet
            hmr: false }), server: Object.assign(Object.assign({}, rsbuildConfig.server), { cors: true }), plugins: [
            ...((_c = rsbuildConfig.plugins) !== null && _c !== void 0 ? _c : []),
            // mappings.getPlugin(),
            (0, plugin_script_module_1.pluginScriptModule)(),
        ], tools: {
            rspack: {
                experiments: {
                    outputModule: true,
                },
                plugins: [mappings.getPlugin()],
                output: {
                    uniqueName: mfConfig.options.name,
                    publicPath: 'auto',
                    chunkFormat: 'module',
                    chunkLoading: 'import',
                    workerChunkLoading: 'import',
                    wasmLoading: 'fetch',
                    library: { type: 'module' },
                    module: true,
                },
                optimization: {
                    runtimeChunk: 'single',
                },
            },
        }, moduleFederation: Object.assign(Object.assign({}, mfConfig), { options: Object.assign(Object.assign({ 
                //
                // Shells use an empty name by default
                // Alternative: Specifiying the *same* name
                // in initFederation (runtime) and
                // withFederation (build time)
                //
                name: '' }, mfConfig.options), { library: Object.assign(Object.assign({}, mfConfig.options.library), { type: 'module' }), remoteType: 'module', filename: 'remoteEntry.js' }) }) });
    return config;
}
//# sourceMappingURL=with-federation.js.map