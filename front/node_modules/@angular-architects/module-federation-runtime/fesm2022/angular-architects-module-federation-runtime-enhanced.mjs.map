{"version":3,"file":"angular-architects-module-federation-runtime-enhanced.mjs","sources":["../../../../libs/mf-runtime/enhanced/src/lib/init-federation.ts","../../../../libs/mf-runtime/enhanced/src/lib/loadRemoteModule.ts","../../../../libs/mf-runtime/enhanced/src/angular-architects-module-federation-runtime-enhanced.ts"],"sourcesContent":["import { init } from '@module-federation/enhanced/runtime';\nimport { FederationHost, UserOptions } from '@module-federation/runtime-core';\n\nexport type ManifestFile<T extends RemoteConfig = RemoteConfig> = {\n  [key: string]: string | T;\n};\n\nexport type Manifest<T extends RemoteConfig = RemoteConfig> = {\n  [key: string]: T;\n};\n\n//\n// remoteEntry is the original used by the orignal\n// webpack-based plugin; entry is used by the new\n// Module Federation Runtime. We support both to\n// avoid confusion.\n//\nexport type RemoteConfig =\n  | {\n      name: string;\n      type: 'module' | 'script';\n      remoteEntry: string;\n      [key: string]: unknown;\n    }\n  | {\n      name: string;\n      type: 'module' | 'script';\n      entry: string;\n      [key: string]: unknown;\n    };\n\nexport type InitFederationOptions = {\n  runtimeOptions?: UserOptions;\n};\n\nlet config: Manifest = {};\n\nexport async function initFederation(\n  manifest: string | ManifestFile,\n  options?: InitFederationOptions\n): Promise<FederationHost> {\n  if (typeof manifest === 'string') {\n    config = await loadManifest(manifest);\n  } else {\n    config = parseConfig(manifest);\n  }\n\n  const runtimeConfig = toRuntimeConfig(config, options);\n  return init(runtimeConfig);\n}\n\nexport function toRuntimeConfig(\n  config: Manifest<RemoteConfig>,\n  options?: InitFederationOptions\n): UserOptions {\n  return {\n    //\n    // The runtime assumes an empty string as the name for\n    // the host. Alternatively, we have to pass the same\n    // name to withFederation (compile time config) and\n    // initFederation (runtime time config on app start)\n    //\n    name: '',\n    ...options?.runtimeOptions,\n    remotes: [\n      ...(options?.runtimeOptions?.remotes ?? []),\n      ...toRemotes(config),\n    ],\n  };\n}\n\nfunction toRemotes(config: Manifest) {\n  return Object.values(config).map((c) => ({\n    name: c.name,\n    entry: (c.entry ?? c.remoteEntry ?? '') as string,\n    type: c.type,\n  }));\n}\n\nexport function getManifest<T extends Manifest>(): T {\n  return config as T;\n}\n\n//  Just needed to align with original webpack-based plugin\nexport async function setManifest(manifest: ManifestFile) {\n  config = parseConfig(manifest);\n}\n\nexport async function loadManifest<T extends Manifest = Manifest>(\n  configFile: string\n): Promise<T> {\n  const result = await fetch(configFile);\n\n  if (!result.ok) {\n    throw Error('could not load configFile: ' + configFile);\n  }\n\n  config = parseConfig(await result.json());\n  return config as T;\n}\n\nexport function parseConfig(config: ManifestFile): Manifest {\n  const result: Manifest = {};\n  for (const key in config) {\n    const value = config[key];\n\n    let entry: RemoteConfig;\n    if (typeof value === 'string') {\n      entry = {\n        name: key,\n        remoteEntry: value,\n        type: 'module',\n      };\n    } else {\n      entry = {\n        ...value,\n        name: key,\n        type: value.type || 'module',\n      };\n    }\n\n    result[key] = entry;\n  }\n  return result;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { loadRemote } from '@module-federation/enhanced/runtime';\n\nexport type LoadRemoteModuleOptions<T = any> = {\n  remoteName: string;\n  exposedModule: string;\n  fallback?: T;\n};\n\nexport async function loadRemoteModule<T = any>(\n  remoteName: string,\n  exposedModule: string\n): Promise<T>;\nexport async function loadRemoteModule<T = any>(\n  options: LoadRemoteModuleOptions\n): Promise<T>;\nexport async function loadRemoteModule<T = any>(\n  optionsOrRemoteName: LoadRemoteModuleOptions<T> | string,\n  exposedModule?: string\n): Promise<T> {\n  const options = normalize(optionsOrRemoteName, exposedModule);\n\n  const remote = options.remoteName;\n  const exposed = normalizeExposed(options.exposedModule);\n\n  const url = [remote, exposed].join('/');\n\n  let result: T | null = null;\n  let error: unknown;\n\n  try {\n    result = await loadRemote<T>(url);\n  } catch (e) {\n    error = e;\n  }\n\n  if (!error && result) {\n    return result;\n  }\n\n  if (options.fallback) {\n    return options.fallback;\n  }\n\n  if (error) {\n    throw error;\n  }\n\n  throw new Error('could not load ' + url);\n}\n\nfunction normalize<T>(\n  optionsOrRemoteName: LoadRemoteModuleOptions<T> | string,\n  exposedModule?: string\n): LoadRemoteModuleOptions<T> {\n  if (typeof optionsOrRemoteName === 'string') {\n    return {\n      remoteName: optionsOrRemoteName,\n      exposedModule: exposedModule ?? '',\n    };\n  } else {\n    return optionsOrRemoteName;\n  }\n}\n\nfunction normalizeExposed(exposed: string): string {\n  if (exposed.startsWith('./')) {\n    return exposed.substring(2);\n  }\n  return exposed;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}