import { init, loadRemote } from '@module-federation/enhanced/runtime';

let config = {};
async function initFederation(manifest, options) {
    if (typeof manifest === 'string') {
        config = await loadManifest(manifest);
    }
    else {
        config = parseConfig(manifest);
    }
    const runtimeConfig = toRuntimeConfig(config, options);
    return init(runtimeConfig);
}
function toRuntimeConfig(config, options) {
    return {
        //
        // The runtime assumes an empty string as the name for
        // the host. Alternatively, we have to pass the same
        // name to withFederation (compile time config) and
        // initFederation (runtime time config on app start)
        //
        name: '',
        ...options?.runtimeOptions,
        remotes: [
            ...(options?.runtimeOptions?.remotes ?? []),
            ...toRemotes(config),
        ],
    };
}
function toRemotes(config) {
    return Object.values(config).map((c) => ({
        name: c.name,
        entry: (c.entry ?? c.remoteEntry ?? ''),
        type: c.type,
    }));
}
function getManifest() {
    return config;
}
//  Just needed to align with original webpack-based plugin
async function setManifest(manifest) {
    config = parseConfig(manifest);
}
async function loadManifest(configFile) {
    const result = await fetch(configFile);
    if (!result.ok) {
        throw Error('could not load configFile: ' + configFile);
    }
    config = parseConfig(await result.json());
    return config;
}
function parseConfig(config) {
    const result = {};
    for (const key in config) {
        const value = config[key];
        let entry;
        if (typeof value === 'string') {
            entry = {
                name: key,
                remoteEntry: value,
                type: 'module',
            };
        }
        else {
            entry = {
                ...value,
                name: key,
                type: value.type || 'module',
            };
        }
        result[key] = entry;
    }
    return result;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
async function loadRemoteModule(optionsOrRemoteName, exposedModule) {
    const options = normalize(optionsOrRemoteName, exposedModule);
    const remote = options.remoteName;
    const exposed = normalizeExposed(options.exposedModule);
    const url = [remote, exposed].join('/');
    let result = null;
    let error;
    try {
        result = await loadRemote(url);
    }
    catch (e) {
        error = e;
    }
    if (!error && result) {
        return result;
    }
    if (options.fallback) {
        return options.fallback;
    }
    if (error) {
        throw error;
    }
    throw new Error('could not load ' + url);
}
function normalize(optionsOrRemoteName, exposedModule) {
    if (typeof optionsOrRemoteName === 'string') {
        return {
            remoteName: optionsOrRemoteName,
            exposedModule: exposedModule ?? '',
        };
    }
    else {
        return optionsOrRemoteName;
    }
}
function normalizeExposed(exposed) {
    if (exposed.startsWith('./')) {
        return exposed.substring(2);
    }
    return exposed;
}

/**
 * Generated bundle index. Do not edit.
 */

export { getManifest, initFederation, loadManifest, loadRemoteModule, parseConfig, setManifest, toRuntimeConfig };
//# sourceMappingURL=angular-architects-module-federation-runtime-enhanced.mjs.map
